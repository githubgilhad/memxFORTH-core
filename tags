!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Asm	properties	/properties (req, vararg for parameters)/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Asm	d,define	/defines/
!_TAG_KIND_DESCRIPTION!Asm	l,label	/labels/
!_TAG_KIND_DESCRIPTION!Asm	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Asm	t,type	/types (structs and records)/
!_TAG_KIND_DESCRIPTION!C	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C	m,member	/struct, and union members/
!_TAG_KIND_DESCRIPTION!C	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!C++	M,module	/modules/
!_TAG_KIND_DESCRIPTION!C++	P,partition	/partitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!D	M,module	/modules/
!_TAG_KIND_DESCRIPTION!D	T,template	/templates/
!_TAG_KIND_DESCRIPTION!D	V,version	/version statements/
!_TAG_KIND_DESCRIPTION!D	X,mixin	/mixins/
!_TAG_KIND_DESCRIPTION!D	a,alias	/aliases/
!_TAG_KIND_DESCRIPTION!D	c,class	/classes/
!_TAG_KIND_DESCRIPTION!D	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!D	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!D	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!D	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!D	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!D	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!D	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!D	u,union	/union names/
!_TAG_KIND_DESCRIPTION!D	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!Asm	1.0	/current.age/
!_TAG_PARSER_VERSION!C	1.1	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PARSER_VERSION!D	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/SHARED/GIT-arduino/MakeArduino/test-002/demos/4.test.0001/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.1.0	//
!_TAG_ROLE_DESCRIPTION!C!function	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C!struct	foreigndecl	/declared in foreign languages/
!_TAG_ROLE_DESCRIPTION!C++!header	exported	/exported with "exported imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C++!module	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!module	partOwner	/used for specifying a partition/
!_TAG_ROLE_DESCRIPTION!C++!partition	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
ANSI_COLORS	colors.h	/^#define ANSI_COLORS /;"	d
BG_BLUE	colors.h	/^	#define BG_BLUE /;"	d
BG_GREEN	colors.h	/^	#define BG_GREEN /;"	d
BG_RED	colors.h	/^	#define BG_RED /;"	d
BG_YELLOW	colors.h	/^	#define BG_YELLOW /;"	d
BOARD_SUB	Makefile	/^BOARD_SUB = atmega328$/;"	m
BOARD_TAG	Makefile	/^BOARD_TAG = nano$/;"	m
CELL_t	test.c	/^typedef uint16_t CELL_t;	\/\/ cell on data stack 2B$/;"	t	typeref:typename:uint16_t	file:
CLR_BLUE	colors.h	/^	#define CLR_BLUE /;"	d
CLR_GREEN	colors.h	/^	#define CLR_GREEN /;"	d
CLR_GREY	colors.h	/^	#define CLR_GREY /;"	d
CLR_HBLUE	colors.h	/^	#define CLR_HBLUE /;"	d
CLR_HCYAN	colors.h	/^	#define CLR_HCYAN /;"	d
CLR_HGREEN	colors.h	/^	#define CLR_HGREEN /;"	d
CLR_HRED	colors.h	/^	#define CLR_HRED /;"	d
CLR_HWHITE	colors.h	/^	#define CLR_HWHITE /;"	d
CLR_HYELLOW	colors.h	/^	#define CLR_HYELLOW /;"	d
CLR_RESET	colors.h	/^	#define CLR_RESET /;"	d
CLR_WHITE	colors.h	/^	#define CLR_WHITE /;"	d
CLR_YELLOW	colors.h	/^	#define CLR_YELLOW /;"	d
CM	ptr24.h	/^#define CM /;"	d
CONST	test.c	/^#define CONST(/;"	d	file:
CodeWord_t	test.c	/^typedef __memx const CodeWord_t (*Data_t);	\/\/ Data_t is 3B pointer to CodeWord_t "somewhere"$/;"	t	typeref:typename:__memx const ()(* Data_t)	file:
CodeWord_t	test.c	/^typedef void(*CodeWord_t)();	\/\/ CodeWord_t is 2B pointer to function (in FLASH) (*CodeWord_t)(/;"	t	typeref:typename:void (*)()	file:
DEBUG_DUMP	debug.h	/^#define DEBUG_DUMP(/;"	d
DEBUG_DUMPu	debug.h	/^#define DEBUG_DUMPu(/;"	d
DEBUG_H	debug.h	/^#define DEBUG_H$/;"	d
DEFCONST	asm.S	/^.macro DEFCONST name	; {{{$/;"	m
DEFVAR	asm.S	/^.macro DEFVAR name	; {{{$/;"	m
DEFWORD	asm.S	/^.macro DEFWORD lbl, attr, name, codeword	; {{{$/;"	m
DT	test.c	/^const __memx Data_t			*DT;	\/\/ Value of last data pointed by IP before NEXT (= address of codep/;"	v	typeref:typename:const __memx Data_t *
Data_t	test.c	/^typedef __memx const Data_t (* InstrPoint_t);	\/\/ InstrPoint_t is 3B pointer to Data_t "somewhe/;"	t	typeref:typename:__memx const ()(* InstrPoint_t)	file:
F	ptr24.h	/^#define F(/;"	d
FLASH_END	debug.c	/^#define FLASH_END /;"	d	file:
FLASH_PTR	asm.S	/^.macro FLASH_PTR addr	; {{{$/;"	m
FLASH_START	debug.c	/^#define FLASH_START /;"	d	file:
FLG_HIDDEN	flags.h	/^#define FLG_HIDDEN	/;"	d
FLG_IMMEDIATE	flags.h	/^#define FLG_IMMEDIATE	/;"	d
FLG_NOFLAG	flags.h	/^#define FLG_NOFLAG	/;"	d
HERE	test.c	/^char *HERE=&RAM[0];$/;"	v	typeref:typename:char *
IO_H	io.h	/^#define IO_H$/;"	d
IP	test.c	/^const __memx InstrPoint_t		*IP;$/;"	v	typeref:typename:const __memx InstrPoint_t *
ISP_PROG	Makefile	/^ISP_PROG=usbasp$/;"	m
LAST	test.c	/^CM head1_t *LAST;$/;"	v	typeref:typename:CM head1_t *
MONITOR_BAUDRATE	Makefile	/^MONITOR_BAUDRATE=115200$/;"	m
NEXT	test.c	/^#define NEXT /;"	d	file:
P	ptr24.h	/^static inline ptr24_u P(ptr24_u p){	\/\/ {{{ Pointer (dereference a return 3Bytes from there)$/;"	f	typeref:typename:ptr24_u
P24p	ptr24.h	/^static inline ptr24_u P24p(CM void * p) { ptr24_u r; r.p24=(CM ptr24_u *)p;r.b4.zero=0; return r/;"	f	typeref:typename:ptr24_u
P24u	ptr24.h	/^static inline ptr24_u P24u(uint32_t u) { ptr24_u r; r.u32=u; return r;}$/;"	f	typeref:typename:ptr24_u
PTR24_H	ptr24.h	/^#define PTR24_H$/;"	d
PTR_t	test.c	/^typedef void __memx const *PTR_t;	\/\/ universal 3B pointer to any data "somewhere"$/;"	t	typeref:typename:void __memx const *	file:
RAM	test.c	/^char RAM[RAM_LEN];$/;"	v	typeref:typename:char[]
RAM_END	debug.c	/^#define RAM_END /;"	d	file:
RAM_LEN	test.c	/^#define RAM_LEN /;"	d	file:
RAM_START	debug.c	/^#define RAM_START /;"	d	file:
Rpeek	test.c	/^PTR_t Rpeek(){ return *(Rstack);}$/;"	f	typeref:typename:PTR_t
Rpop	test.c	/^PTR_t Rpop() {$/;"	f	typeref:typename:PTR_t
Rpush	test.c	/^void Rpush(PTR_t x) {$/;"	f	typeref:typename:void
Rstack	test.c	/^PTR_t *Rstack=&Rstck[STACK_LEN];$/;"	v	typeref:typename:PTR_t *
Rstck	test.c	/^PTR_t Rstck[STACK_LEN];$/;"	v	typeref:typename:PTR_t[]
STACK_LEN	test.c	/^#define STACK_LEN	/;"	d	file:
STYLE_BOLD	colors.h	/^	#define STYLE_BOLD /;"	d
USER_LIB_PATH	Makefile	/^USER_LIB_PATH= $(ARDMK_DIR)\/libs\/$/;"	m
V	ptr24.h	/^static inline ptr24_u V(ptr24_u p){p.b4.zero=0;return p;};	\/\/ Verify, Value, sanitise$/;"	f	typeref:typename:ptr24_u
VAR	test.c	/^#define VAR(name,value)	CELL_t name=(CELL_t)value;VARf/;"	d	file:
VARfn	test.c	/^#define VARfn(/;"	d	file:
VARfn	test.c	/^VARfn(HERE)$/;"	f	typeref:typename:STATE
\\lbl	asm.S	/^	.global \\lbl$/;"	s	inputSection:.text
\\lbl\\()_cw	asm.S	/^	.global \\lbl\\()_cw$/;"	s	inputSection:.text
\\lbl\\()_data	asm.S	/^	.global \\lbl\\()_data$/;"	s	inputSection:.text
\\lbl\\()_head	asm.S	/^	.global \\lbl\\()_head$/;"	s	inputSection:.text
__anon1dda1bf60103	test.c	/^typedef enum { st_executing, st_compiling} st_STATE;$/;"	g	file:
b3	ptr24.h	/^	b3_t b3;$/;"	m	union:ptr24_u	typeref:typename:b3_t
b3_t	ptr24.h	/^typedef struct b3_t {	 \/\/ {{{ \/\/ === 24-bit pointer type ===$/;"	s
b3_t	ptr24.h	/^} b3_t; \/\/ }}}$/;"	t	typeref:struct:b3_t
b4	ptr24.h	/^	b4_t b4;$/;"	m	union:ptr24_u	typeref:typename:b4_t
b4_t	ptr24.h	/^typedef struct b4_t {	 \/\/ {{{ \/\/ === 32-bit pointer type ===$/;"	s
b4_t	ptr24.h	/^} b4_t; \/\/ }}}$/;"	t	typeref:struct:b4_t
bank	ptr24.h	/^	uint8_t bank;$/;"	m	struct:b3_t	typeref:typename:uint8_t
bank	ptr24.h	/^	uint8_t bank;$/;"	m	struct:b4_t	typeref:typename:uint8_t
cmvp	ptr24.h	/^typedef const __memx void *cmvp;$/;"	t	typeref:typename:const __memx void *
comma	test.c	/^void comma(Data_t d) {	\/\/ {{{$/;"	f	typeref:typename:void
debug_dump	debug.c	/^void debug_dump(const __memx void * address, const __memx char* label) {	 \/\/ {{{$/;"	f	typeref:typename:void
end	asm.S	/^	.global end$/;"	s	inputSection:.text
error	debug.c	/^void error(const __memx char *c) { 	\/\/ {{{$/;"	f	typeref:typename:void
f_branch	test.c	/^void f_branch(){ 	 \/\/ {{{$/;"	f	typeref:typename:void
f_comma	test.c	/^void f_comma() {	\/\/ {{{ take 3B address (2 CELLs) from datastack and put it to HERE$/;"	f	typeref:typename:void
f_debug	test.c	/^void f_debug(void) {	\/\/ {{{ \/\/ === f_debug: return from FOTH or what ===$/;"	f	typeref:typename:void
f_docol	test.c	/^void f_docol() {	\/\/ {{{$/;"	f	typeref:typename:void
f_dot	test.c	/^void f_dot() { 	 \/\/ {{{$/;"	f	typeref:typename:void
f_exit	test.c	/^void f_exit(){	\/\/ {{{$/;"	f	typeref:typename:void
f_interpret	test.c	/^void f_interpret(){	 \/\/ {{{$/;"	f	typeref:typename:void
f_key	test.c	/^void f_key(){	 \/\/ {{{ WAITS for char and puts it on stack$/;"	f	typeref:typename:void
f_lit	test.c	/^void f_lit(){	\/\/ {{{ README: LIT takes the next 3B pointer as 2B integer, ignores the top byte/;"	f	typeref:typename:void
f_number	test.c	/^void f_number() {	\/\/ {{{ (addr n -- rest val) rest= #neprevedenych znaku$/;"	f	typeref:typename:void
f_plus	test.c	/^void f_plus(){	\/\/ {{{$/;"	f	typeref:typename:void
f_word	test.c	/^void f_word() {	 \/\/ {{{ Put address and size of buff to stack$/;"	f	typeref:typename:void
f_words	test.c	/^void f_words(void) {	\/\/ {{{ print all words$/;"	f	typeref:typename:void
f_words_name	test.c	/^const __memx char f_words_name[]="WORDS";$/;"	v	typeref:typename:const __memx char[]
findHead	test.c	/^xpHead1 findHead(uint8_t len,const char *wordname, xpHead1 h) { 	\/\/ {{{$/;"	f	typeref:typename:xpHead1
flags	test.c	/^	uint8_t flags;		\/\/ 1B: $/;"	m	struct:head1_t	typeref:typename:uint8_t	file:
get_codeword_addr	test.c	/^Data_t get_codeword_addr(xpHead1 h){	 \/\/ {{{$/;"	f	typeref:typename:Data_t
get_word	test.c	/^void get_word(){	 \/\/ {{{ WAITS for word and puts it into word_buf_len + word_buf$/;"	f	typeref:typename:void
head1_t	test.c	/^typedef struct head1_t {	\/\/ {{{$/;"	s	file:
head1_t	test.c	/^} head1_t;	\/\/ }}}$/;"	t	typeref:struct:head1_t	file:
here	asm.S	/^	.global here$/;"	s	inputSection:.text
here	asm.S	/^here:$/;"	l
hex	debug.c	/^const __memx char hex[] = "0123456789ABCDEF";$/;"	v	typeref:typename:const __memx char[]
hi	ptr24.h	/^	uint8_t hi;$/;"	m	struct:b3_t	typeref:typename:uint8_t
hi	ptr24.h	/^	uint8_t hi;$/;"	m	struct:b4_t	typeref:typename:uint8_t
info	debug.c	/^void info(const __memx char *c) { 	\/\/ {{{$/;"	f	typeref:typename:void
is_flash_address	debug.c	/^bool is_flash_address(uint32_t addr) {	 \/\/ {{{$/;"	f	typeref:typename:bool
is_ram_address	debug.c	/^bool is_ram_address(uint32_t addr) {	 \/\/ {{{$/;"	f	typeref:typename:bool
len	test.c	/^	uint8_t len;		\/\/ 1B: up to 31 (=5bits)$/;"	m	struct:head1_t	typeref:typename:uint8_t	file:
len\\@	asm.S	/^	.equ len\\@,(. - name_start_\\@)$/;"	d
lo	ptr24.h	/^	uint8_t lo;$/;"	m	struct:b3_t	typeref:typename:uint8_t
lo	ptr24.h	/^	uint8_t lo;$/;"	m	struct:b4_t	typeref:typename:uint8_t
loop	4.test.0001.cpp	/^void loop(){$/;"	f	typeref:typename:void
my_loop	test.c	/^void my_loop(){	\/\/ {{{$/;"	f	typeref:typename:void
my_setup	test.c	/^void my_setup(){	\/\/ {{{$/;"	f	typeref:typename:void
name	test.c	/^	const char name[];	\/\/ len B:name of WORD$/;"	m	struct:head1_t	typeref:typename:const char[]	file:
next	test.c	/^	__memx const struct head1_t *next;		\/\/ 3B: pointer to next header "somewhere"$/;"	m	struct:head1_t	typeref:typename:const struct head1_t *	file:
next	test.c	/^void next(){$/;"	f	typeref:typename:void
nodebug	debug.c	/^bool nodebug=true;$/;"	v	typeref:typename:bool
nodebug	debug.h	/^bool nodebug;$/;"	v	typeref:typename:bool
p24	ptr24.h	/^	const __memx union ptr24_u* p24;$/;"	m	union:ptr24_u	typeref:typename:const union ptr24_u *
p24u32	ptr24.h	/^static inline uint32_t p24u32(cmvp p) {ptr24_u r; r.p24=p; r.b4.zero=0;return r.u32;}$/;"	f	typeref:typename:uint32_t
peek	test.c	/^CELL_t peek(){ return *(stack);}$/;"	f	typeref:typename:CELL_t
pop	test.c	/^CELL_t pop() {$/;"	f	typeref:typename:CELL_t
print_words	test.c	/^void print_words(void) {	\/\/ {{{ \/\/ === print all wocabulary$/;"	f	typeref:typename:void
ptr24_u	ptr24.h	/^typedef union  ptr24_u {	\/\/ {{{ b3 x uint32_t x const __memx void* union$/;"	u
ptr24_u	ptr24.h	/^} ptr24_u; \/\/ }}}$/;"	t	typeref:union:ptr24_u
push	test.c	/^void push(CELL_t x) {$/;"	f	typeref:typename:void
read_char	4.test.0001.cpp	/^	char read_char() {$/;"	f	typeref:typename:char
read_memx	debug.c	/^static inline uint8_t read_memx(uint32_t addr) {	 \/\/ {{{$/;"	f	typeref:typename:uint8_t	file:
setup	4.test.0001.cpp	/^void setup(){$/;"	f	typeref:typename:void
st_STATE	test.c	/^typedef enum { st_executing, st_compiling} st_STATE;$/;"	t	typeref:enum:__anon1dda1bf60103	file:
st_compiling	test.c	/^typedef enum { st_executing, st_compiling} st_STATE;$/;"	e	enum:__anon1dda1bf60103	file:
st_executing	test.c	/^typedef enum { st_executing, st_compiling} st_STATE;$/;"	e	enum:__anon1dda1bf60103	file:
stack	test.c	/^CELL_t *stack=&stck[STACK_LEN];$/;"	v	typeref:typename:CELL_t *
stck	test.c	/^CELL_t stck[STACK_LEN];$/;"	v	typeref:typename:CELL_t[]
top_head	asm.S	/^	.EQU	top_head,1b-3$/;"	d
top_head	asm.S	/^	.global top_head$/;"	s	inputSection:.text
track	test.c	/^void track(const __memx char * label) {	 \/\/ {{{$/;"	f	typeref:typename:void
u32	ptr24.h	/^	uint32_t u32;$/;"	m	union:ptr24_u	typeref:typename:uint32_t
u32p24	ptr24.h	/^static inline cmvp u32p24(uint32_t u) {ptr24_u r; r.u32=u; r.b4.zero=0;return r.p24;}$/;"	f	typeref:typename:cmvp
wait_for_char	io.c	/^char wait_for_char() {	\/\/ {{{$/;"	f	typeref:typename:char
word_buf	test.c	/^char word_buf[32];$/;"	v	typeref:typename:char[32]
word_buf_len	test.c	/^uint8_t word_buf_len=0;$/;"	v	typeref:typename:uint8_t
write_char	4.test.0001.cpp	/^	void write_char(char c) {$/;"	f	typeref:typename:void
write_charA	4.test.0001.cpp	/^	void write_charA(char c) {$/;"	f	typeref:typename:void
write_eoln	io.c	/^void write_eoln() { 	\/\/ {{{$/;"	f	typeref:typename:void
write_hex	test.c	/^void write_hex(uint16_t i) { 	\/\/ {{{$/;"	f	typeref:typename:void
write_hex16	debug.c	/^void write_hex16(uint16_t w) {$/;"	f	typeref:typename:void
write_hex24	debug.c	/^void write_hex24(uint32_t w) {$/;"	f	typeref:typename:void
write_hex32	debug.c	/^void write_hex32(uint32_t w) {$/;"	f	typeref:typename:void
write_hex8	debug.c	/^void write_hex8(uint8_t b) {$/;"	f	typeref:typename:void
write_str	io.c	/^void write_str(const __memx char *c) { 	\/\/ {{{$/;"	f	typeref:typename:void
xpB	test.c	/^typedef __memx const uint8_t *xpB;	\/\/ 3B pointer 1B target	pointer "somewhere" to byte "somewh/;"	t	typeref:typename:__memx const uint8_t *	file:
xpC	test.c	/^typedef __memx const char *xpC;	\/\/ 3B pointer 1B target	pointer "somewhere" to char "somewhere/;"	t	typeref:typename:__memx const char *	file:
xpD	test.c	/^typedef __memx const uint32_t *xpD;$/;"	t	typeref:typename:__memx const uint32_t *	file:
xpHead1	test.c	/^typedef __memx const head1_t	*xpHead1;	\/\/ 3B pointer to head1 "somewhere"$/;"	t	typeref:typename:__memx const head1_t *	file:
zero	ptr24.h	/^	uint8_t zero;$/;"	m	struct:b4_t	typeref:typename:uint8_t
